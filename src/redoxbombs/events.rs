use game_element::Bomb;
use game_element::Fire;

/// An `InputEvent` is an event produced as a consequence
/// of a user input.
#[derive(Debug)]
pub enum InputEvent {
    /// Move the player towards `direction`.
    PlayerMove(Direction),

    /// Create a new `Bomb` at the `Player` postion.
    PlayerCreateBomb,

    /// Stop the game keeping the state.
    GamePause,

    /// Set the system to exit.
    GameQuit,
}

/// A `GameEvent` is an event generated by the game to allow
/// their elements to handle requests in a RoundRobin way.
#[derive(Debug)]
pub enum GameEvent {
    /// Increment the number of bombs available for the player.
    PlayerRecoverBomb,

    /// Initializes a new enemy creating the needed events.
    EnemyInit { id: usize },

    /// Allow enemy with identifier `id` to check collision
    /// with other game elements.
    EnemyCheckCollision { id: usize },

    /// Allow enemy with number `id` to move.
    EnemyMove { id: usize },

    /// Initialize already created bomb.
    BombInit { id: usize },

    /// Set a bomb to explode.
    BombExplode { id: usize },

    /// Set the fire to burn.
    FireInit { id: usize },

    /// Allow fire with identifier `id` to check collision
    /// with other game elements.
    FireCheckCollision { id: usize },

    /// Put the fire out.
    FirePutOut { id: usize },

    /// Check if the player collides with the stairs.
    StairsCheckCollision,
}

/// A `ResultEvent`is an event produced by a `GameElement`
/// as a consequence of processing an `InputEvent`.
///
/// The possibe values are:
#[derive(Debug)]
pub enum ResultEvent {
    /// Stop the game keeping the state.
    GamePause,

    /// Leave the main loop.
    GameExit,

    /// State that the game world state has been updated. It is
    /// useful for actions that take place on update like rendering.
    GameUpdated,

    /// Schedule a game event to be executed after `millis` milliseconds.
    GameScheduleEvent { millis: u64, event: GameEvent },

    /// Convert `ResultEvent` to `GameEvent`.
    GameSetEvent { event: GameEvent },

    /// Break the Maze Tile at position `x` and `y`.
    MazeBreak { x: usize, y: usize },

    /// The player died so exit the game.
    PlayerDied,

    /// Delete the enemy with id `id from the level.
    EnemyDelete { id: usize },

    /// Include bomb to level and schedule it to explode.
    BombNew { bomb: Bomb },

    /// Delete the bomb with id `id` from the level.
    BombDelete { id: usize },

    /// Include fire to level and schedule it to put out.
    FireNew { fire: Fire },

    /// Delete the fire with id `id` from the level.
    FireDelete { id: usize },

    /// Change the game to the next level.
    NextLevel,
}

/// It defines the four directions that can be take by the
/// player.
#[derive(Debug)]
pub enum Direction {
    /// Towards north.
    Up,

    /// Towards south.
    Down,

    /// Toards west.
    Left,

    /// Toards east.
    Right,
}
